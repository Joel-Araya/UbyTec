{"version":3,"file":"application_ref.d.ts","sources":["application_ref.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Observable } from 'rxjs';\r\nimport { InjectionToken, Injector, StaticProvider } from './di';\r\nimport { CompilerOptions } from './linker/compiler';\r\nimport { ComponentFactory, ComponentRef } from './linker/component_factory';\r\nimport { NgModuleFactory, NgModuleRef } from './linker/ng_module_factory';\r\nimport { ViewRef } from './linker/view_ref';\r\nimport { Type } from './type';\r\nimport { NgZone } from './zone/ng_zone';\r\nexport declare function compileNgModuleFactory__POST_R3__<M>(injector: Injector, options: CompilerOptions, moduleType: Type<M>): Promise<NgModuleFactory<M>>;\r\nexport declare const ALLOW_MULTIPLE_PLATFORMS: InjectionToken<boolean>;\r\n/**\r\n * A token for third-party components that can register themselves with NgProbe.\r\n *\r\n * @publicApi\r\n */\r\nexport declare class NgProbeToken {\r\n    name: string;\r\n    token: any;\r\n    constructor(name: string, token: any);\r\n}\r\n/**\r\n * Creates a platform.\r\n * Platforms have to be eagerly created via this function.\r\n *\r\n * @publicApi\r\n */\r\nexport declare function createPlatform(injector: Injector): PlatformRef;\r\n/**\r\n * Creates a factory for a platform\r\n *\r\n * @publicApi\r\n */\r\nexport declare function createPlatformFactory(parentPlatformFactory: ((extraProviders?: StaticProvider[]) => PlatformRef) | null, name: string, providers?: StaticProvider[]): (extraProviders?: StaticProvider[]) => PlatformRef;\r\n/**\r\n * Checks that there currently is a platform which contains the given token as a provider.\r\n *\r\n * @publicApi\r\n */\r\nexport declare function assertPlatform(requiredToken: any): PlatformRef;\r\n/**\r\n * Destroy the existing platform.\r\n *\r\n * @publicApi\r\n */\r\nexport declare function destroyPlatform(): void;\r\n/**\r\n * Returns the current platform.\r\n *\r\n * @publicApi\r\n */\r\nexport declare function getPlatform(): PlatformRef | null;\r\n/**\r\n * Provides additional options to the bootstraping process.\r\n *\r\n *\r\n */\r\nexport interface BootstrapOptions {\r\n    /**\r\n     * Optionally specify which `NgZone` should be used.\r\n     *\r\n     * - Provide your own `NgZone` instance.\r\n     * - `zone.js` - Use default `NgZone` which requires `Zone.js`.\r\n     * - `noop` - Use `NoopNgZone` which does nothing.\r\n     */\r\n    ngZone?: NgZone | 'zone.js' | 'noop';\r\n}\r\n/**\r\n * The Angular platform is the entry point for Angular on a web page. Each page\r\n * has exactly one platform, and services (such as reflection) which are common\r\n * to every Angular application running on the page are bound in its scope.\r\n *\r\n * A page's platform is initialized implicitly when a platform is created via a platform factory\r\n * (e.g. {@link platformBrowser}), or explicitly by calling the {@link createPlatform} function.\r\n *\r\n * @publicApi\r\n */\r\nexport declare class PlatformRef {\r\n    private _injector;\r\n    private _modules;\r\n    private _destroyListeners;\r\n    private _destroyed;\r\n    /**\r\n     * Creates an instance of an `@NgModule` for the given platform\r\n     * for offline compilation.\r\n     *\r\n     * @usageNotes\r\n     * ### Simple Example\r\n     *\r\n     * ```typescript\r\n     * my_module.ts:\r\n     *\r\n     * @NgModule({\r\n     *   imports: [BrowserModule]\r\n     * })\r\n     * class MyModule {}\r\n     *\r\n     * main.ts:\r\n     * import {MyModuleNgFactory} from './my_module.ngfactory';\r\n     * import {platformBrowser} from '@angular/platform-browser';\r\n     *\r\n     * let moduleRef = platformBrowser().bootstrapModuleFactory(MyModuleNgFactory);\r\n     * ```\r\n     */\r\n    bootstrapModuleFactory<M>(moduleFactory: NgModuleFactory<M>, options?: BootstrapOptions): Promise<NgModuleRef<M>>;\r\n    /**\r\n     * Creates an instance of an `@NgModule` for a given platform using the given runtime compiler.\r\n     *\r\n     * @usageNotes\r\n     * ### Simple Example\r\n     *\r\n     * ```typescript\r\n     * @NgModule({\r\n     *   imports: [BrowserModule]\r\n     * })\r\n     * class MyModule {}\r\n     *\r\n     * let moduleRef = platformBrowser().bootstrapModule(MyModule);\r\n     * ```\r\n     *\r\n     */\r\n    bootstrapModule<M>(moduleType: Type<M>, compilerOptions?: (CompilerOptions & BootstrapOptions) | Array<CompilerOptions & BootstrapOptions>): Promise<NgModuleRef<M>>;\r\n    private _moduleDoBootstrap;\r\n    /**\r\n     * Register a listener to be called when the platform is disposed.\r\n     */\r\n    onDestroy(callback: () => void): void;\r\n    /**\r\n     * Retrieve the platform {@link Injector}, which is the parent injector for\r\n     * every Angular application on the page and provides singleton providers.\r\n     */\r\n    readonly injector: Injector;\r\n    /**\r\n     * Destroy the Angular platform and all Angular applications on the page.\r\n     */\r\n    destroy(): void;\r\n    readonly destroyed: boolean;\r\n}\r\n/**\r\n * A reference to an Angular application running on a page.\r\n *\r\n * @usageNotes\r\n *\r\n * {@a is-stable-examples}\r\n * ### isStable examples and caveats\r\n *\r\n * Note two important points about `isStable`, demonstrated in the examples below:\r\n * - the application will never be stable if you start any kind\r\n * of recurrent asynchronous task when the application starts\r\n * (for example for a polling process, started with a `setInterval`, a `setTimeout`\r\n * or using RxJS operators like `interval`);\r\n * - the `isStable` Observable runs outside of the Angular zone.\r\n *\r\n * Let's imagine that you start a recurrent task\r\n * (here incrementing a counter, using RxJS `interval`),\r\n * and at the same time subscribe to `isStable`.\r\n *\r\n * ```\r\n * constructor(appRef: ApplicationRef) {\r\n *   appRef.isStable.pipe(\r\n *      filter(stable => stable)\r\n *   ).subscribe(() => console.log('App is stable now');\r\n *   interval(1000).subscribe(counter => console.log(counter));\r\n * }\r\n * ```\r\n * In this example, `isStable` will never emit `true`,\r\n * and the trace \"App is stable now\" will never get logged.\r\n *\r\n * If you want to execute something when the app is stable,\r\n * you have to wait for the application to be stable\r\n * before starting your polling process.\r\n *\r\n * ```\r\n * constructor(appRef: ApplicationRef) {\r\n *   appRef.isStable.pipe(\r\n *     first(stable => stable),\r\n *     tap(stable => console.log('App is stable now')),\r\n *     switchMap(() => interval(1000))\r\n *   ).subscribe(counter => console.log(counter));\r\n * }\r\n * ```\r\n * In this example, the trace \"App is stable now\" will be logged\r\n * and then the counter starts incrementing every second.\r\n *\r\n * Note also that this Observable runs outside of the Angular zone,\r\n * which means that the code in the subscription\r\n * to this Observable will not trigger the change detection.\r\n *\r\n * Let's imagine that instead of logging the counter value,\r\n * you update a field of your component\r\n * and display it in its template.\r\n *\r\n * ```\r\n * constructor(appRef: ApplicationRef) {\r\n *   appRef.isStable.pipe(\r\n *     first(stable => stable),\r\n *     switchMap(() => interval(1000))\r\n *   ).subscribe(counter => this.value = counter);\r\n * }\r\n * ```\r\n * As the `isStable` Observable runs outside the zone,\r\n * the `value` field will be updated properly,\r\n * but the template will not be refreshed!\r\n *\r\n * You'll have to manually trigger the change detection to update the template.\r\n *\r\n * ```\r\n * constructor(appRef: ApplicationRef, cd: ChangeDetectorRef) {\r\n *   appRef.isStable.pipe(\r\n *     first(stable => stable),\r\n *     switchMap(() => interval(1000))\r\n *   ).subscribe(counter => {\r\n *     this.value = counter;\r\n *     cd.detectChanges();\r\n *   });\r\n * }\r\n * ```\r\n *\r\n * Or make the subscription callback run inside the zone.\r\n *\r\n * ```\r\n * constructor(appRef: ApplicationRef, zone: NgZone) {\r\n *   appRef.isStable.pipe(\r\n *     first(stable => stable),\r\n *     switchMap(() => interval(1000))\r\n *   ).subscribe(counter => zone.run(() => this.value = counter));\r\n * }\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\nexport declare class ApplicationRef {\r\n    private _zone;\r\n    private _console;\r\n    private _injector;\r\n    private _exceptionHandler;\r\n    private _componentFactoryResolver;\r\n    private _initStatus;\r\n    private _bootstrapListeners;\r\n    private _views;\r\n    private _runningTick;\r\n    private _enforceNoNewChanges;\r\n    private _stable;\r\n    /**\r\n     * Get a list of component types registered to this application.\r\n     * This list is populated even before the component is created.\r\n     */\r\n    readonly componentTypes: Type<any>[];\r\n    /**\r\n     * Get a list of components registered to this application.\r\n     */\r\n    readonly components: ComponentRef<any>[];\r\n    /**\r\n     * Returns an Observable that indicates when the application is stable or unstable.\r\n     *\r\n     * @see  [Usage notes](#is-stable-examples) for examples and caveats when using this API.\r\n     */\r\n    readonly isStable: Observable<boolean>;\r\n    /**\r\n     * Bootstrap a new component at the root level of the application.\r\n     *\r\n     * @usageNotes\r\n     * ### Bootstrap process\r\n     *\r\n     * When bootstrapping a new root component into an application, Angular mounts the\r\n     * specified application component onto DOM elements identified by the componentType's\r\n     * selector and kicks off automatic change detection to finish initializing the component.\r\n     *\r\n     * Optionally, a component can be mounted onto a DOM element that does not match the\r\n     * componentType's selector.\r\n     *\r\n     * ### Example\r\n     * {@example core/ts/platform/platform.ts region='longform'}\r\n     */\r\n    bootstrap<C>(componentOrFactory: ComponentFactory<C> | Type<C>, rootSelectorOrNode?: string | any): ComponentRef<C>;\r\n    /**\r\n     * Invoke this method to explicitly process change detection and its side-effects.\r\n     *\r\n     * In development mode, `tick()` also performs a second change detection cycle to ensure that no\r\n     * further changes are detected. If additional changes are picked up during this second cycle,\r\n     * bindings in the app have side-effects that cannot be resolved in a single change detection\r\n     * pass.\r\n     * In this case, Angular throws an error, since an Angular application can only have one change\r\n     * detection pass during which all change detection must complete.\r\n     */\r\n    tick(): void;\r\n    /**\r\n     * Attaches a view so that it will be dirty checked.\r\n     * The view will be automatically detached when it is destroyed.\r\n     * This will throw if the view is already attached to a ViewContainer.\r\n     */\r\n    attachView(viewRef: ViewRef): void;\r\n    /**\r\n     * Detaches a view from dirty checking again.\r\n     */\r\n    detachView(viewRef: ViewRef): void;\r\n    private _loadComponent;\r\n    private _unloadComponent;\r\n    /**\r\n     * Returns the number of attached views.\r\n     */\r\n    readonly viewCount: number;\r\n}\r\n"]}