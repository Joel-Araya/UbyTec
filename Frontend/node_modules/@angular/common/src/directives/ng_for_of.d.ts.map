{"version":3,"file":"ng_for_of.d.ts","sources":["ng_for_of.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA","sourcesContent":["/**\r\n * @license\r\n * Copyright Google Inc. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { DoCheck, IterableDiffers, NgIterable, TemplateRef, TrackByFunction, ViewContainerRef } from '@angular/core';\r\n/**\r\n * @publicApi\r\n */\r\nexport declare class NgForOfContext<T> {\r\n    $implicit: T;\r\n    ngForOf: NgIterable<T>;\r\n    index: number;\r\n    count: number;\r\n    constructor($implicit: T, ngForOf: NgIterable<T>, index: number, count: number);\r\n    readonly first: boolean;\r\n    readonly last: boolean;\r\n    readonly even: boolean;\r\n    readonly odd: boolean;\r\n}\r\n/**\r\n * A [structural directive](guide/structural-directives) that renders\r\n * a template for each item in a collection.\r\n * The directive is placed on an element, which becomes the parent\r\n * of the cloned templates.\r\n *\r\n * The `ngForOf` is generally used in the\r\n * [shorthand form](guide/structural-directives#the-asterisk--prefix) `*ngFor`.\r\n * In this form, the template to be rendered for each iteration is the content\r\n * of an anchor element containing the directive.\r\n *\r\n * The following example shows the shorthand syntax with some options,\r\n * contained in an `<li>` element.\r\n *\r\n * ```\r\n * <li *ngFor=\"let item of items; index as i; trackBy: trackByFn\">...</li>\r\n * ```\r\n *\r\n * The shorthand form expands into a long form that uses the `ngForOf` selector\r\n * on an `<ng-template>` element.\r\n * The content of the `<ng-template>` element is the `<li>` element that held the\r\n * short-form directive.\r\n *\r\n * Here is the expanded version of the short-form example.\r\n *\r\n * ```\r\n * <ng-template ngFor let-item [ngForOf]=\"items\" let-i=\"index\" [ngForTrackBy]=\"trackByFn\">\r\n *   <li>...</li>\r\n * </ng-template>\r\n * ```\r\n *\r\n * Angular automatically expands the shorthand syntax as it compiles the template.\r\n * The context for each embedded view is logically merged to the current component\r\n * context according to its lexical position.\r\n *\r\n * When using the shorthand syntax, Angular allows only [one structural directive\r\n * on an element](guide/structural-directives#one-structural-directive-per-host-element).\r\n * If you want to iterate conditionally, for example,\r\n * put the `*ngIf` on a container element that wraps the `*ngFor` element.\r\n * For futher discussion, see\r\n * [Structural Directives](guide/structural-directives#one-per-element).\r\n *\r\n * @usageNotes\r\n *\r\n * ### Local variables\r\n *\r\n * `NgForOf` provides exported values that can be aliased to local variables.\r\n * For example:\r\n *\r\n *  ```\r\n * <li *ngFor=\"let user of userObservable | async as users; index as i; first as isFirst\">\r\n *    {{i}}/{{users.length}}. {{user}} <span *ngIf=\"isFirst\">default</span>\r\n * </li>\r\n * ```\r\n *\r\n * The following exported values can be aliased to local variables:\r\n *\r\n * - `$implicit: T`: The value of the individual items in the iterable (`ngForOf`).\r\n * - `ngForOf: NgIterable<T>`: The value of the iterable expression. Useful when the expression is\r\n * more complex then a property access, for example when using the async pipe (`userStreams |\r\n * async`).\r\n * - `index: number`: The index of the current item in the iterable.\r\n * - `first: boolean`: True when the item is the first item in the iterable.\r\n * - `last: boolean`: True when the item is the last item in the iterable.\r\n * - `even: boolean`: True when the item has an even index in the iterable.\r\n * - `odd: boolean`: True when the item has an odd index in the iterable.\r\n *\r\n * ### Change propagation\r\n *\r\n * When the contents of the iterator changes, `NgForOf` makes the corresponding changes to the DOM:\r\n *\r\n * * When an item is added, a new instance of the template is added to the DOM.\r\n * * When an item is removed, its template instance is removed from the DOM.\r\n * * When items are reordered, their respective templates are reordered in the DOM.\r\n *\r\n * Angular uses object identity to track insertions and deletions within the iterator and reproduce\r\n * those changes in the DOM. This has important implications for animations and any stateful\r\n * controls that are present, such as `<input>` elements that accept user input. Inserted rows can\r\n * be animated in, deleted rows can be animated out, and unchanged rows retain any unsaved state\r\n * such as user input.\r\n * For more on animations, see [Transitions and Triggers](guide/transition-and-triggers).\r\n *\r\n * The identities of elements in the iterator can change while the data does not.\r\n * This can happen, for example, if the iterator is produced from an RPC to the server, and that\r\n * RPC is re-run. Even if the data hasn't changed, the second response produces objects with\r\n * different identities, and Angular must tear down the entire DOM and rebuild it (as if all old\r\n * elements were deleted and all new elements inserted).\r\n *\r\n * To avoid this expensive operation, you can customize the default tracking algorithm.\r\n * by supplying the `trackBy` option to `NgForOf`.\r\n * `trackBy` takes a function that has two arguments: `index` and `item`.\r\n * If `trackBy` is given, Angular tracks changes by the return value of the function.\r\n *\r\n * @see [Structural Directives](guide/structural-directives)\r\n * @ngModule CommonModule\r\n * @publicApi\r\n */\r\nexport declare class NgForOf<T> implements DoCheck {\r\n    private _viewContainer;\r\n    private _template;\r\n    private _differs;\r\n    ngForOf: NgIterable<T>;\r\n    ngForTrackBy: TrackByFunction<T>;\r\n    private _ngForOf;\r\n    private _ngForOfDirty;\r\n    private _differ;\r\n    private _trackByFn;\r\n    constructor(_viewContainer: ViewContainerRef, _template: TemplateRef<NgForOfContext<T>>, _differs: IterableDiffers);\r\n    ngForTemplate: TemplateRef<NgForOfContext<T>>;\r\n    ngDoCheck(): void;\r\n    private _applyChanges;\r\n    private _perViewChange;\r\n    /**\r\n     * Asserts the correct type of the context for the template that `NgForOf` will render.\r\n     *\r\n     * The presence of this method is a signal to the Ivy template type-check compiler that the\r\n     * `NgForOf` structural directive renders its template with a specific context type.\r\n     */\r\n    static ngTemplateContextGuard<T>(dir: NgForOf<T>, ctx: any): ctx is NgForOfContext<T>;\r\n}\r\nexport declare function getTypeNameForDebugging(type: any): string;\r\n"]}